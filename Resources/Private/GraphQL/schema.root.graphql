type Query {
  asset(identifier: ID!): Asset
  assets(tag: String): [Asset!]!
  assetProxies(assetSource: AssetSource!, tag: String, assetCollection: String, assetType: String, limit: Int, offset: Int): [AssetProxy!]!
  assetSources: [AssetSource!]!
  assetCollections: [AssetCollection!]!
  assetTypes: [AssetType!]!
  assetCount(assetSource: AssetSource!, tag: String, assetCollection: String, assetType: String): Int!
  tags: [Tag!]!
}

# The default local asset source is `neos`. Other externals ones can be available through plugins.
type AssetSource {
    identifier: ID!
    label: String!
    readOnly: Boolean!
    supportsTagging: Boolean!
    supportsCollections: Boolean!
}

# The main type that should be queries to fetch assets.
# The proxy reflects local and external asset data.
# Local and already imported assets have the `localAssetIdentifier` set and `localAssetData` available.
type AssetProxy {
    identifier: ID!
    label: String!
    filename: String!
    lastModified: String! # TODO: introduce custom scalar for Date types
    fileSize: Int!
    mediaType: String!
    fileTypeIcon: FileTypeIcon!
    widthInPixels: Int
    heightInPixels: Int
    thumbnailUri: String # Provides an image uri for thumbnails views
    previewUri: String # Provides a full size image uri for details views
    assetSource: AssetSource!
    localAssetIdentifier: String
    localAssetData: Asset
}

type Asset {
    identifier: ID!
    title: String
    label: String!
    caption: String
    mediaType: String!
    fileExtension: String!
    filename: String!
    copyrightNotice: String
    thumbnail: String
    tags: [Tag!]!
    assetCollections: [AssetCollection!]!
    # TODO: implement `variants: [AssetVariant]`
}

type AssetType {
    label: String!
}

type Tag {
    label: String!
}

type AssetCollection {
    title: String!
    assets: [Asset]
    tags: [Tag]
}

type FileTypeIcon {
    src: String!
    alt: String
}

schema {
  query: Query
}
